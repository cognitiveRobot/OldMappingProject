//============================================================================
// Name        : Algorithm3.cpp
// Author      : Hossain
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================
#include <iostream>
#include <stdio.h>
#include <dirent.h>
#include <vector>
#include <cmath>
#include <sstream>
#include <algorithm>
#include <string>

#include "readAndwriteASCII.H"
#include "Plotting.H"
#include "GeometricOp.H"

#include "Point.H"
#include "Object.H"
#include "asr.H"
#include "mfisOp.H"
#include "asrOp.H"
#include "PathPlanning.H"
#include "Transporter.H"

#include "Minfo.H"
#include "Map.H"
#include "CompareASR.H"
#include "Mapping.H"

#include "PointAndSurface.H"
#include "convexPathPlanner.h"
#include "PolygonChoice.h"
#include "PerceptualMapping.H"
#include "Comparison.h"

#include "thesis.H"

#include <cstdlib>
#include <ctime>

#define PI 3.14159265
using namespace std;

int main() {
    int v, w, level, set, saveFrom, saveTo;
    string printAll, readLogFile, loopCl, localizeA;

    bool needToCloseLoop;
    bool localizeAlways = false;

    level = 1; //cin >> level;
    cout << "How many views?? ";
    cin >> set;
    v = 15;
    w = set;
    
    if(loopCl == "y") {
        needToCloseLoop = true;
    }
    else
        needToCloseLoop = false;
    
    if(localizeA == "y") {
        localizeAlways = true;
    }

    //printASingleScan();//for thesis
    //waitHere();

    bool computeASR = false;


    int referenceNumberTH = 0;
    char mappingInfoFileName[100];

    for (int exp = 0; exp < 1; exp++) {
        //v = 1;
        if (exp == 0)
            referenceNumberTH = 3;
        else
            referenceNumberTH = 1;
        sprintf(mappingInfoFileName, "%s%d%s", "Maps/MappingInfo-refTh-", referenceNumberTH, ".txt");
        //variables
        Transporter recognizedTargetObjects, computedOutput;
        vector <double> coordTransInfo;
        vector<Object> targetObjectsInPV, targetObjectsInCV, targetObjectsInMFIS;
        vector<Object> allTargetObjectsInPV;
        vector<Object> referenceObjects, odometricReferenceObject;
        vector<Object> currentRobotPositionInMFIS, odometricCRPositionInMFIS;
        vector<Object> previousRobotPositionInMFIS;
        vector<Object> routeMap;
        vector<Object> routeMapForOneASR;
        vector<Object> routeMapConnLP; //route map simply connecting limiting points
        Object pathFromLastLimitingPoint;
        vector<vector<Object> > routeMapForallASR;
        Object lastRouteMapNode, tempLastRouteMapNode;
        vector <Object> allRobotPositions, allOdometricRPosition;
        vector< vector<Object> > allRPoseAtOneStep;
        vector<Object> robotPositionsAtLimitingPoints;
        Transporter objectForPlaceRecognition;
        Transporter loopClosingInfo;
        Transporter lastStepInfo;
        vector<Object> refObjectForLoopClosing;
        string environmentType = "unknown";
        vector<int> lostPoints, limitingPoints, exitPoints, badLocalization;
        Object lineOfSitePoint;
        limitingPoints.push_back(1);
        Object lastLocomotion;
        vector<Object> wholeRoute;
        double traveledDistance = 0;
        double robotFacing = 0; //in degree


        int odoLocalizationUsed = 0;
        ofstream outFile("Maps/LocalizationError.txt", ios::out);

        vector<Exit> exitsFromCV;
        vector<Object> exitsFromCVInMFIS, allExitsInMFIS, crossedExit;

        vector<Object> objectOfCurrentASR;
        ASR currentASR;
        ASRNetwork perceptualMap;
        int ASRNumber = 1;

        vector<ASR> places;

        MyRobot myrobot(0, 0);
        currentRobotPositionInMFIS = myrobot.getRobot();
        allRobotPositions = currentRobotPositionInMFIS;
        allOdometricRPosition = currentRobotPositionInMFIS; //just to see odometric robot position
        odometricCRPositionInMFIS = currentRobotPositionInMFIS; //just to see odometric robot position
        robotPositionsAtLimitingPoints = currentRobotPositionInMFIS;

        //for routeMap
        previousRobotPositionInMFIS = currentRobotPositionInMFIS;
        lastRouteMapNode = currentRobotPositionInMFIS[6];
        tempLastRouteMapNode = lastRouteMapNode;
        routeMap.push_back(lastRouteMapNode);
        routeMapForOneASR.push_back(lastRouteMapNode);
        routeMapConnLP.push_back(Object(0, 0, 0, 0, 1));

        if (readLogFile == "y") {
            //readAlbotKBCInput(); //read albot1's keyboar controlled input to save for all
            //albot1 and dpslam and gridSlam(carmen format)
            //carmenToAlbot1Converter();//reads carmen's keyborad controlled input to convert albot1
            //carmenToCarmenConverter(); //read from carmen file generated by carmen 
            //readAlbotInput4DPSLAM(118);
            //readDPSLAMInput4DPSLAM("bin/loop5.log");//skipping few steps
            //readInput("bin/comInput/loop5.log");
            //readCarmenInput("bin/KeyBoardControlled/wholefloor-CW-Robot1.log");
            //readDPSLAMInput("bin/Canada/canada.txt");
            //readDPSLAMInput("bin/comInput/loop5.log");//for set100
            cout << "LogFILE reading finished. " << endl;
            waitHere();
        }
        const char* levelName = "inputData/level";
        const char* surfaceName = "/surfaces-";
        char viewFileName[80], mfisFileName[80], ctFileName[80];
        sprintf(viewFileName, "%s%d%s%d%s%d", levelName, level, "set", set, surfaceName, v);

        //reading the first view
        cout << "........Reading " << viewFileName << endl;
        vector <Object> currentView = readASCII(viewFileName);
        if (currentView.size() == 0) {
            cout << "Need to change the file name" << endl;
            surfaceName = "/surface-";
            sprintf(viewFileName, "%s%d%s%d%s%d", levelName, level, "set", set, surfaceName, v);
            currentView = readASCII(viewFileName);
        }

        //finding target objects
        targetObjectsInPV = findTargetObjects(currentView);
        referenceObjects.push_back(targetObjectsInPV[0]); //bcz ref objects will be used in findNextDestination function
        referenceObjects.push_back(targetObjectsInPV[0]);

        //tagging side and view number
        currentView = tagObjectsAsSideAndViewNumber(currentView, 1);

        for (unsigned int i = 0; i < currentView.size(); i++) {
            currentView[i].setASRNo(1);
            currentView[i].setLimitingPoint(1);
            currentView[i].setLocalEnvID(1);
        }

        //initializing MFIS
        vector<Object> MFIS = currentView;
        cout << "..........MFIS.........." << endl;
        displayObjects(MFIS);
        //waitHere();

        //initializing Perceptual Map
        objectOfCurrentASR = currentView;
        currentASR.setASRObjects(objectOfCurrentASR);
        currentASR.setASRExit1(Object(-500, 0, 500, 0));
        currentASR.setASRID(1);
        lineOfSitePoint = currentRobotPositionInMFIS[6];
        currentASR.addLineOfSitePoints(currentRobotPositionInMFIS[6]);
        perceptualMap.setCurrentASR(currentASR);

        //    ConvexRobotPathPlanner myPathPlanner(5, 400);//2nd arg.
        //    PointXY goal(0,1200);
        Destination nextDestination;
        double angle = 0;
        double distance = 0;

        sprintf(mfisFileName, "%s%d%s", "Maps/MFIS-", v, ".png");
        sprintf(viewFileName, "%s%d%s", "Maps/view-", v, ".png");
        plotObjectsOf3Kinds(viewFileName, allRobotPositions, targetObjectsInPV, currentView);
        plotObjects(mfisFileName, allRobotPositions, MFIS);
        //plotObjects("Maps/targetSFromV1.png", allRobotPositions, breakTheLinesInto(targetObjectsInPV)); //for thesis

        vector<Object> firstView = MFIS; //for thesis
        vector<Object> fTS = targetObjectsInPV; //for thesis

        cout << "home: " << currentRobotPositionInMFIS[6].distP1ToP1(currentView[4]) << endl;
        //    tmpMA.set(0,0,currentView[currentView.size()-1].X1(),currentView[currentView.size()-1].Y1(),1);
        //    allRobotPositions.push_back(tmpMA);

        vector<Object> errorMap = currentView; //odometric error map initialization


        vector<Point> updatingPoints;
        updatingPoints.push_back(Point(0, 0));

        int exitCounter = 0;
        bool exitCrossed = false;
        crossedExit.push_back(currentRobotPositionInMFIS[6]); //consider home as a exit
        crossedExit.back().setID(v);

        vector<Object> destinationExitsInCV, destinationExitsInMFIS, alldestinationExitsInMFIS, exitInCVToReachGoal;
        vector<pair<double, double> > invalidatedExitGoals, invalidatedGoals;
        pair<double, double> goal;
        string goalType;

        vector<Object> dummy;
        vector<vector< Object> > allRPosition4ThisStep;
        double usedRefDistanceError, usedRefAngleError;
	
        vector<int> failedToRecognizeRef;
        ofstream outFileForRefError("Maps/Localization", ios::out);
        outFileForRefError << v << " " << 1 << endl;
        cout << "\n\033[1;34m******************MFIS is computed at step" << v << "********************\033[0m" << endl << endl;
        do {
            v++;
            cout << "@ step " << v << endl;

            sprintf(ctFileName, "%s%d%s%d%s%d", levelName, level, "set", set, "/coordTrans-", v);
            coordTransInfo = readCoordTrans(ctFileName);

            traveledDistance = traveledDistance + coordTransInfo[0];
            robotFacing = robotFacing + coordTransInfo[1];
            // errorMap = addTwoVectorsOfObjects(errorMap,xformPObjectsIntoCV())

            //changing the filenames 
            sprintf(viewFileName, "%s%d%s%d%s%d", levelName, level, "set", set, surfaceName, v);
            //reading current view and coordinate transformation info
            cout << endl << endl << "........Reading " << viewFileName << endl;
            currentView = readASCII(viewFileName);
            if (currentView.size() == 0) {
                cout << "Need to change the file name" << endl;
                surfaceName = "/surface-";
                sprintf(viewFileName, "%s%d%s%d%s%d", levelName, level, "set", set, surfaceName, v);
                currentView = readASCII(viewFileName);
            }
            //recognizeViews(MFIS,currentView);
            cout << v << " coordTrans d- " << coordTransInfo[0] << " a- " << coordTransInfo[1] << endl;
            odometricErrorMap(errorMap, currentView, coordTransInfo[0], coordTransInfo[1]); //computing error map
     

            
        } while (v < w); //(v != 79);//  //(v != 55); //  while(n == 'y' || n == 'Y');//
        cout << "MFIS size " << MFIS.size() << " all robot position size " << allRobotPositions.size() << endl;

        outFile.close();
        outFileForRefError.close();
        //localization 
        currentRobotPositionInMFIS = myrobot.inMFIS(referenceObjects[0], referenceObjects[1], referenceObjects[0].getKP());

        vector<Object> firstAndLastRP = myrobot.getRobot();
        for (int i = 0; i < currentRobotPositionInMFIS.size(); i++) {
            firstAndLastRP.push_back(currentRobotPositionInMFIS[i]);
        }
        

        cout << "Traveled Dist: " << traveledDistance << endl;
        writeASCII(convertObjectToSurface(MFIS), "Maps/pm"); //for thesis
        plotObjects("Maps/errorMapWholeFloor.png", errorMap, firstAndLastRP); //for thesis
        perceptualMap.setMFIS(MFIS);
        // if (computeASR == true) {
        //abstractASRs(places,MFIS,routeMapForallASR,refObjectForLoopClosing);
        //}

        abstractRouteMap(MFIS, robotPositionsAtLimitingPoints, updatingPoints, currentRobotPositionInMFIS);
        keyInfoOfCompuetedPM(mappingInfoFileName, ASRNumber, exitPoints, lostPoints, limitingPoints,
                badLocalization, failedToRecognizeRef, referenceNumberTH, level, set);
        cout << levelName << level << " set " << set << endl;
        cout << "odo " << odoLocalizationUsed << endl;

    }
    return 0;
}

